<span  style="font-family: Simsun,serif; font-size: 17px; ">

[TOC]

- 架构图
- ![架构图](./pic/Cluster.png)

### 1. 结构

Redis Cluster要求至少需要3个master才能组成一个集群，同时每个master至少需要有一个slave节点。各个节点之间保持TCP通信。当master发生了宕机， Redis Cluster自动会将对应的slave节点提拔为master，来重新对外提供服务。

- 负载均衡
- 故障切换
- 主从复制

### 2. 负载均衡

- 总槽数为：16384（2^14）
- 如果有3台master，那么每台负责5461个槽（16384/3）。

| 节点  | 槽位            |
|-----|---------------|
| 1   | 0-5461        |
| 2   | 5461-10922    |
| 3   | 10922-16383   |

- 算法
~~~
当redis客户端设置值时，会拿key进行CRC16算法，然后 跟16384取模，得到的就是落在哪个槽位，根据上面表格就得出在哪台节点
slot = CRC16(key) & 16383
~~~
- 所以值会散落在三个上面

### 3. 故障切换

当一个从节点发现主从复制的主节点下线时,
1. 会执行SLAVEOF no one命令，成为新的主节点；
2. 新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己；
3. 新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。
4. 新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。

### 4. 主从复制

#### 4.1 简单步奏

1. 从维护了 master的ip和port
2. 从slave定时任务，每一秒检查是否有新的master要连接和复制，如果有简历socket链接
3. 口令 requirepass
4. master第一次全量复制,将所有数据发给slave(run id不同就做全量复制)
5. master后续秩序将写命令,复制给slave

#### 4.2 全量复制过程

1. 主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令。
2. 主节点的bgsave执行完成后，将RDB文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态。
3. 主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态
4. 如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态。

#### 4.3 服务器运行ID(runid)

1. 每个Redis节点(无论主从)，在启动时都会自动生成一个随机ID(每次启动都不一样)，由40个随机的十六进制字符组成；runid用来唯一识别一个Redis节点。通过info Server命令，可以查看节点的runid：
~~~
redis-cli info server | grep dun_id
~~~
2. 主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行全量复制：
3. 如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，进行全量复制。



</span>