<font face="Simsun" size=3>

- [三种模式](https://blog.csdn.net/weixin_49724150/article/details/121659693)
- [面试问题](https://blog.csdn.net/qq_40430818/article/details/121802858)
- [死锁](https://blog.csdn.net/luokn1995/article/details/108371863)

[TOC]

### 数据结构
~~~
String
List
set
hash -> hashmap
sorted_set -> treeset
~~~

### 持久化

~~~
Rdb
Rdb是redis DataBase缩写功能核心函数rdbSave（生成rdb文件）和rdbLoad（从文件加载内存）两个函数。

Aof是append-only file缩写
每当执行服务器（定时）任务或者函数flushAppendOnlyFile函数都会被调用，这个函数执行以下两个工作。

Rdb与Aof对比
1、aof文件比rdb更新频率高，优先使用aof还原数据。
2、Aof比rdb更安全也更大
3、Rdb性能比aof好
4、如果两个都配置了优先加载aof
~~~


- 故障转移,
- 集群中的节点会向其它节点发送PING消息（该PING消息会带着当前集群和节点的信息），如果在规定时间内，没有收到对应的PONG消息，就把此节点标记为疑似下线
- 


### 什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？

~~~
缓存穿透：
一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value值，就应该去后端系统查询（比如DB）。一些恶意的请求会故意查询不存在的key，请求量很大，就会对后台系统造成很大的压力。这就叫缓存穿透。
如何避免：
1、对查询结果为空的情况下也进行缓存，缓存时间设置短一点，或者该key对应的数insert了之后清理缓存。
2、对一定不存在的key值进行过滤。可以把所有的可能存在的key放到一个大的bitmap中，查询是通过bitmap过滤。
缓存雪崩：
当缓存服务器重启或者缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大的压力。导致系统崩溃。
如何避免：
1、在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询和写缓存，其他线程等待。
2、做二级缓存，a1为原始缓存，a2为拷贝缓存，a1失效时，可以访问a2，a1缓存时间设置短期，a2设置为长期。
3、不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。
~~~


### 分布式锁

1. Redisson框架

- 只要线程一加锁成功，就会启动一个watch dog看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用Redisson解决了「锁过期释放，业务没执行完」问题。
- 会每隔10秒检查一下，如果线程1还持有锁
- 重入锁
~~~
redis存储的信息是Hash类型
Hash数据类型的key包含了线程信息
~~~


2. Redlock+Redisson

- 按顺序向5个master节点请求加锁
- 根据设置的超时时间来判断，是不是要跳过该master节点。
- 如果大于等于3个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。
- 如果获取锁失败，解锁！

### 死锁

- 线程获取锁，执行lua脚本，成功就保存到redis
- 获取失败就会循环获取
~~~
1. Redisson 设置超时时间
2. watch dog后台线程，演唱key的生存时间
3. lua脚本封装业务发送给redis，redis是单线程的，保证业务略记得原子性
4. 那部分是单线程的 TODO 
~~~
- 性能
~~~
锁的粒度要小,比如库存，那就单独商品ID，范围不要太大
锁的范围，哪行代码要锁，就锁哪行
~~~

</font>