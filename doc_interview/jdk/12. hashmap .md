<span  style="font-family: Simsun,serif; font-size: 17px; ">

- [参考](https://wenku.baidu.com/view/79197504ac45b307e87101f69e3143323968f5c7.html)
- 2022-04-27 还没看完


### 1. 简介

1. 为什么用链表
~~~
底层是数组，当map进行pust时候，进行hash计算。判断对象属于数组的哪个位置，
如果在同一个数组上面的时候会有hash冲突，所以引入链表
~~~

2. 红黑树
~~~
链表>8,数组>64
红黑树相对于链表维护成本大，还要通过旋转来保持平衡，维护成本高，所以数据小不用红黑树
~~~

3. & 同为1才为1
~~~
tab[(n - 1) & hash]
速度快
~~~

4. 为什么是2的幂
~~~
1. 减少hash冲突，均匀分布
2. &运算速度快，比取模速度快
3. 能保证索引在 capacity中，不会超出数组长度
~~~


### 2. node

内部类Node<K,V>,实现Entry接口，本质上是一个映射
~~~
static class Node<K,V> implements Map.Entry<K,V> {
        // hash: key的哈希值
        final int hash;
        // 节点的key: 类型和定义HashMap的key相同
        final K key;
        // value
        V value;
        // 该节点的下一节点
        Node<K,V> next;// 可以不断的得到下一个数据
~~~

### 3. 容量

1. 默认是16 1 << 4
2. 加载因子 0.75
3. 超过 容量*加载因子时,扩容
4. 如果已经知道数据量，最好提前设置 2 的倍数

### hash

1. 高16位和底16位做异或运算，如果不这样就相当于只有hash()返回值的末x为运算
2. 冲突高一些，这样高位和低位都用，减少冲突
3. 异或,不同1，相同为0
~~~
   // 减少hash冲突的概率
   //
   static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
~~~

### jdk1.8

1. 当链表大于8(数组长度大于64)的时候，便利查找效率慢，所以引入红黑树


### null

~~~
HashMap最多只允许一个键为Null(多条会覆盖)，但允许多个值为Null
~~~

### 底层数组长度

**HashMap 的底层数组长度为何总是2的n次方**
- HashMap根据用户传入的初始化容量，利用无符号右移和按位或运算等方式计算出第一个大于该数的2的幂。
- `使数据分布均匀，减少碰撞
- 当length为2的n次方时，h&(length - 1) 就相当于对length取模，而且在速度、效率上比直接取模要快得多

**为什么是16**
- 2的倍数,太小了就有可能频繁发生扩容，影响效率。太大了又浪费空间，不划算。



~~~
JDK1.8中resize()方法在表为空时，创建表；在表不为空时，扩容；而JDK1.7中resize()方法负责扩容，inflateTable()负责创建表。
1.8中没有区分键为null的情况，而1.7版本中对于键为null的情况调用putForNullKey()方法。但是两个版本中如果键为null，那么调用hash()方法得到的都将是0，所以键为null的元素都始终位于哈希表table【0】中。
当1.8中的桶中元素处于链表的情况，遍历的同时最后如果没有匹配的，直接将节点添加到链表尾部；而1.7在遍历的同时没有添加数据，而是另外调用了addEntry()方法，将节点添加到链表头部。
1.7中新增节点采用头插法，1.8中新增节点采用尾插法。这也是为什么1.8不容易出现环型链表的原因。
1.7中是通过更改hashSeed值修改节点的hash值从而达到rehash时的链表分散，而1.8中键的hash值不会改变，rehash时根据（hash&oldCap）==0将链表分散。
1.8 rehash时保证原链表的顺序，而1.7中rehash时有可能改变链表的顺序（头插法导致）。 在扩容的时候：1.7在插入数据之前扩容，而1.8插入数据成功之后扩容。
~~~


### CurrentHashMap

- CAS是compare and swap的缩写，即我们所说的比较交换。cas是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。
- 局部加锁
- 


</span>