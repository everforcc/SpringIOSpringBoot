<span  style="font-family: Simsun,serif; font-size: 17px; ">

- [参考](http://www.zjmainstay.cn/my-regexp#1%E5%85%A5%E9%97%A8%E6%AD%A3%E5%88%99%E5%AD%97%E7%AC%A6)
- [2](http://www.zjmainstay.cn/deep-regexp)

[TOC]

使用的分析总结

## 一. 入门

### 1. 匹配除了任意字符

~~~
# 匹配除了换行的任意字符
(.*?)
~~~

### 2. 包括换行

~~~
# 包括换行
([\s\S]*?)
~~~

### 3. [] ^ - \

- 表示括号内取一个,例如
- [abc] 取出a或b或c
- ^ [^abc] 排除abc
- - 范围 [0-9a-z]
- \ 在括号内转义，以上五个字符

### 4. 规范 ^$

- 表示正则开始和结束，之前经常不写，在整个表达式开始和结束

### 5. {0,1}

- {0,1}
- {1}
- {0,}

### 6. ? 两种用法

1. 一个或者0个

~~~
abc?匹配ab 0个c 或abc 1个c
~~~

2. 非贪婪模式

匹配尽可能少的内容
~~~
<div>a</div><div>b</div>
~~~

~~~
# 非贪婪 

<div>(.*?)</div>
# 匹配两个 <div>a</div>
# <div>b</div> 如果有换行，用 [/s/S] 来代替 .
因为遇到第一个</div>的时候就不再向下找了，而下面的就会找，直到最后一个

# 贪婪 匹配一个 <div>a</div><div>b</div>
<div>(.*)</div>
~~~

### 7. | 多个数据选1

单个字符可以用[]，多个字符用 |
~~~
private static String a = "http abc";
private static String b = "ftp abc";
private static String c = "svn abc";

private static String abcReg = "http|ftp|svn abc";

# 结果为 
# http 
# ftp 
# svn abc
# 因为两个 | 将字符串分为了三份

private static String abcRegor = "(http|ftp|svn) abc";

# http abc
# ftp abc 
# svn abc
# 前面括号内选一个，然后加上 abc组合成的字符串

~~~

### 8. ()数据分界和取数据

- 上面例子(http|ftp|svn) abc就是数据分界的例子，然后，匹配结果会得到一个[1]的子集数据（数组下标1），这里就是子模式的概念，子模式也叫分组，利用子模式，可以得到想要取出来的数据。子模式1、2、3的计算方法为左括号的计数，从左到右，从1开始，比如：
- (http|ftp|svn)://([^/]+)，分组1得到的是(http|ftp|svn)里面的数据，分组2得到([^/]+)里面的数据，对于嵌套括号也是点左括号即可。在正则中有很多与括号结合的写法，你在数左括号的时候，一定要注意，非捕获组和环视的左括号都是不需要数的。
- 在使用子模式过程中，常见两种写法是：\1 和 $1。

1.  \1 是在正则表达式本身中引用分组1的内容，如：
    我们要匹配111这样的连续出现3此的数字，我们可以写出正则：(\d)\1\1，(\d)匹配到第一个1，后面再引用这个匹配内容，得到111。
2.  $1 是在替换中调用分组的内容，如：
    我们要替换链接参数name=Zjmainstay为username=Zjmainstay，我们可以使用正则name=([^&]+)替换为username=$1来实现，这里的$1就引用了分组1的结果Zjmainstay，因此得到我们想要的结果。

### 9. (?:) 非捕获组

- ()作为子模式可以得到它里面的数据，但是，有些时候，()只是作为数据分界功能，并不需要取出来，这时候就要用到非捕获组的概念了。
- (?:) 不计入组数

### 10. 模式修饰符 复杂的还不清楚

- i 不区分大小写

## 二. 锚点

唯一定位数据的标识，html的id之类的


## 三. 去噪点

- 也就是子模式，用组只取出想要的数据，而不需要代码重新加工
- 整体是0,从做第一个括号为1，排除非捕获组

## 高级

### 1. 按单字符匹配

我要匹配0-15的数值区间，用正则来写的话，便是[0-9]|1[0-5]，这里，便是把0-9这种单字符的情况，和10-15这种多字符的情况拆分开了，使用分支|来区分开，表示要么是0-9，要么是10-15。
上面是两位数值的情况，现在延伸至1-65535，我个人的处理思想是从大到小，一块块分解：

~~~
1. 65530-65535  ==>  6553[0-5]          末位区间0-5
2. 65500-65529  ==>  655[0-2][0-9]      第四位区间0-2，末位区间0-9
3. 65000-65499  ==>  65[0-4][0-9]{2}    第三位区间0-4，后两位0-9
4. 60000-64999  ==>  6[0-4][0-9]{3}     第二位区间0-4，后三位0-9
5. 10000-59999  ==>  [1-5][0-9]{4}      第一位区间1-5，后四位0-9
6. 1-9999       ==>  [1-9][0-9]{0,3}    第一位只能是1-9，后三位可有可无
~~~

最后组合起来：
(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3})
便得到1-65535匹配正则。

根据数据处理需求，可以在正则前后加上^和$，以匹配整个数据串，或者前后加入\b，把它当做单词边界处理。没有限定字符的边界往往是js正则判断中常见的错误之一。

### 2. 贪婪模式和非贪婪模式

正则的贪婪模式和非贪婪模式是一个比较容易混淆的概念，不过，我们可以这么理解，一个人很贪婪，所以他会能拿多少拿多少，换过来，那就是贪婪模式下的正则表达式，能匹配多少就匹配多少，尽可能最多。而非贪婪模式，则是能不匹配就不匹配，尽可能最少。

~~~
需求：匹配1后面跟任意个0
源串：10001
使用贪婪模式：10*       结果：1000 和 1
使用非贪婪模式：10*?    结果：1 和 1
~~~

- 一般使用非贪婪模式，因为贪婪模式会导致 元字符范围限制不严谨 而导致匹配越界，得到非预期结果
- 效率



### 3. 环视 (断言/零宽断言)

用一句通俗的话解释：
环视，就是先从全局环顾一遍正则，（然后断定结果，）再做进一步匹配处理。
断言，就是先从全局环顾一遍正则，然后断定结果，再做进一步匹配处理。

两个虽然字面不一样，意思却是同一个，都是做全局观望，再做进一步处理。







</span>