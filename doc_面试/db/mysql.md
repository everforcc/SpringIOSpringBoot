<font face="Simsun" size=3>

- [参考](https://wenku.baidu.com/view/c82e5f3029f90242a8956bec0975f46527d3a76f.html)

### 优化

1. 查询优化，避免全表扫描,在where和order by上简历索引
2. 不要再where后面使用 !=和<> 操作,否则会全表扫描
3. 给null设置默认值,否则会扫描
4. 不要使用or，用union all来合并
5. like
6. in和not in，如果是数字，可以用and
7. 不要在where后对字段进行表达式操作


### 索引

1. 对数据表里所有记录的引用指针。
2. 索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。而且索引是一个文件，它是要占据物理空间的。
~~~
创建表的时候
ALTER TABLE table_name ADD INDEX index_name (column_list);
~~~


####　优点

1. 查询速度变快
2. 提高性能

#### 缺点

1. 创建维护索引要消耗时间
2. 修改数据也要维护索引
3. 占用额外的物理空间

#### 索引类型

1. 普通索引： 单列
2. 唯一索引： 索引的值唯一，允许空值
3. 复合索引： 多个列组成索引,用于组合搜索，提升效率
4. 

---

- InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。
1. 聚簇索引
2. 非聚簇索引

---

- 实现，hash表

### 建立索引的原则

1. 设置非空字段，mysqlnull很难优化/设置为0
2. 最左前缀匹配原则, 会一直向右匹配到范围查询(<>,between,like)
3. 选择唯一的键，流水号等
4. 索引不能参与计算, +-，函数都不行
5. 扩展索引，而不要建立新的索引 a列索引，需要(a,b)那么只需要修改原来的索引
6. 主键是连续的

### 查询一定快吗

1. 插入，删除更新会变慢，需要额外的空间
2. 基于一个范围的检索，一般查询返回结果集小于表中记录数的30%


### 索引失效

1. !=,<>
2. 类型不一致
3. 对列进行操作，除法，函数
4. or条件
5. 模糊搜索
6. in,exist

### 为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？

1. B+树的读写代价更低: B+树的内部节点并没有指向关键字具体信息的指针，所以说更小
一个磁盘能存的数据就更多，IO读写次数就更少
2. B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，
但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。
3. hash: 无需，IO复杂度高
不是按照索引值排序，不能利用索引排序
hash在= 查询比较快
如果重复键值，效率低，因为会hash碰撞


</font>