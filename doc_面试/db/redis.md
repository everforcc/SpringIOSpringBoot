<font face="Simsun" size=3>

- [参考](https://blog.csdn.net/weixin_49724150/article/details/121659693)

[TOC]

### 数据结构
~~~
String
List
set
~~~

### 持久化

~~~
Rdb
Rdb是redis DataBase缩写功能核心函数rdbSave（生成rdb文件）和rdbLoad（从文件加载内存）两个函数。

Aof是append-only file缩写
每当执行服务器（定时）任务或者函数flushAppendOnlyFile函数都会被调用，这个函数执行以下两个工作。

Rdb与Aof对比
1、aof文件比rdb更新频率高，优先使用aof还原数据。
2、Aof比rdb更安全也更大
3、Rdb性能比aof好
4、如果两个都配置了优先加载aof
~~~

### 几种模式

~~~
主从 sentinel.conf
    优点:     同一个Master可以同步多个Slaves。
              master能自动将数据同步到slave，可以进行读写分离，分担master的读压力
              master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求
    缺点:     不具备容错和恢复功能  
               难以火绒，取决于单机的上线
                 

哨兵 基于主从复制
    优点: master挂了，子节点升级为master
    
    缺点: 切换需要时间丢数据，没办法解决master写的压力

集群(直连)
    优点:     1.无中心结构，链接任意一个节点即可
             2. 支持扩容
             3. 
    1、资源隔离型较差，容易出现相互影响的情况。
    2、数据通过异步复制，不保证数据的一致性。

~~~
- 故障转移,
- 集群中的节点会向其它节点发送PING消息（该PING消息会带着当前集群和节点的信息），如果在规定时间内，没有收到对应的PONG消息，就把此节点标记为疑似下线
- 


### 什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？

~~~
缓存穿透：
一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value值，就应该去后端系统查询（比如DB）。一些恶意的请求会故意查询不存在的key，请求量很大，就会对后台系统造成很大的压力。这就叫缓存穿透。
如何避免：
1、对查询结果为空的情况下也进行缓存，缓存时间设置短一点，或者该key对应的数insert了之后清理缓存。
2、对一定不存在的key值进行过滤。可以把所有的可能存在的key放到一个大的bitmap中，查询是通过bitmap过滤。
缓存雪崩：
当缓存服务器重启或者缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大的压力。导致系统崩溃。
如何避免：
1、在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询和写缓存，其他线程等待。
2、做二级缓存，a1为原始缓存，a2为拷贝缓存，a1失效时，可以访问a2，a1缓存时间设置短期，a2设置为长期。
3、不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。
~~~


### 分布式锁

1. Redisson框架

- 只要线程一加锁成功，就会启动一个watch dog看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用Redisson解决了「锁过期释放，业务没执行完」问题。
- 会每隔10秒检查一下，如果线程1还持有锁

2. Redlock+Redisson

- 按顺序向5个master节点请求加锁
- 根据设置的超时时间来判断，是不是要跳过该master节点。
- 如果大于等于3个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。
- 如果获取锁失败，解锁！

### 死锁

</font>