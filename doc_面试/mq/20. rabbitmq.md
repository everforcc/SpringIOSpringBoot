<font face="Simsun" size=3>

[TOC]

### 简介

1. 解耦
~~~
将消息发到mq，谁用谁去拿

时间耗费将长、对核心业务不造成影响的非核心业务和核心业务进行解耦
比如下订单业务和下订单后发短信发优惠券等业务应该进行解耦，

~~~
2. 异步
~~~
接受请求放入mq后，直接返回等待别人处理

多线程实现异步会消耗cpu资源，当单机配置达到瓶颈时就会影响到核心业务线程，发生cpu竞争问题
而MQ实现异步是完全解耦的，可以在多个服务器上异步处理不同的业务，因此在分布式开发中经常使用
~~~
3. 幂等
~~~
- 全局唯一业务id
- redis
~~~
4. 峰值
~~~
系统性能有限，每次从mq取出一部分数据处理
~~~
5. 集群
~~~
~~~
6. 开启持久化
~~~
1、生产者
开启消息确认机制，并在发送前对消息进行持久化（redis）
2、MQ
开启MQ的持久化
3、消费者
关闭消息自动确认机制，进行手动确认
~~~
7. 过期
~~~
~~~
8. 延迟队列
~~~
比如下订单后如果用户未付款需要延迟对订单进行取消，这时候可以下订单后将订单信息放入延迟队列中，延迟队列的消息过期后加入取消队列（死信队列），消费取消队列中的消息并判断订单是否已付款，如果未付款的话进行取消订单。
~~~
9. 一致性
~~~
那就把他们放在一个队列中，然后只用一个消费者单线程的来处理消息。
确保消息投递到同一个队列
~~~
10. 保证mysql和redis数据一致性
~~~
1. 用完数据后直接删除，下次从数据库读取数据
~~~

### 消息堆积处理

~~~
1. 提高消费者消费速率（对消费者实现集群）
2. 消费者批量获取消息，减少网络传输次数
~~~

### 幂等性

- 就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。
- 可以通过分布式锁来解决
~~~
这样使用redis实现分布式锁，这次订单请求完成前，下次订单请求只能等待获取锁。
~~~









</font>