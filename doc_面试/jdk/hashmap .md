<font face="Simsun" size=3>

~~~
ConcurrentHashMap
- 
~~~


~~~
底层数据结构不一样，1.7是数组+链表，1.8则是数组+链表+红黑树结构（当链表长度大于8，转为红黑树）。
JDK1.8中resize()方法在表为空时，创建表；在表不为空时，扩容；而JDK1.7中resize()方法负责扩容，inflateTable()负责创建表。
1.8中没有区分键为null的情况，而1.7版本中对于键为null的情况调用putForNullKey()方法。但是两个版本中如果键为null，那么调用hash()方法得到的都将是0，所以键为null的元素都始终位于哈希表table【0】中。
当1.8中的桶中元素处于链表的情况，遍历的同时最后如果没有匹配的，直接将节点添加到链表尾部；而1.7在遍历的同时没有添加数据，而是另外调用了addEntry()方法，将节点添加到链表头部。
1.7中新增节点采用头插法，1.8中新增节点采用尾插法。这也是为什么1.8不容易出现环型链表的原因。
1.7中是通过更改hashSeed值修改节点的hash值从而达到rehash时的链表分散，而1.8中键的hash值不会改变，rehash时根据（hash&oldCap）==0将链表分散。
1.8 rehash时保证原链表的顺序，而1.7中rehash时有可能改变链表的顺序（头插法导致）。 在扩容的时候：1.7在插入数据之前扩容，而1.8插入数据成功之后扩容。
~~~

1. HashMap的内部数据结构
   数组 + 链表/红黑树

2. HashMap允许空键空值么
   HashMap最多只允许一个键为Null(多条会覆盖)，但允许多个值为Null

3. 影响HashMap性能的重要参数
   初始容量：创建哈希表(数组)时桶的数量，默认为 16
   负载因子：哈希表在其容量自动增加之前可以达到多满的一种尺度，默认为 0.75

4. HashMap的工作原理
   HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象

5. 

6.HashMap 的底层数组长度为何总是2的n次方
- HashMap根据用户传入的初始化容量，利用无符号右移和按位或运算等方式计算出第一个大于该数的2的幂。
- `使数据分布均匀，减少碰撞
当length为2的n次方时，h&(length - 1) 就相当于对length取模，而且在速度、效率上比直接取模要快得多

9. 为什么是16
- 2的倍数,太小了就有可能频繁发生扩容，影响效率。太大了又浪费空间，不划算。


</font>